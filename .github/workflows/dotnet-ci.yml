name: Common .NET setup and build workflow

on:
  workflow_call:
    inputs:
      solutionName:
        required: true
        type: string
        description: 'Name of the solution file WITHOUT the extension. On top of running the build. It is ued to calculate the format of the unit tests, benchmarks and integration tests.'
      useSlnx:
        required: false
        type: boolean
        default: false
        description: 'If true, uses .slnx solution format instead of .sln'
      buildOs:
        required: false
        type: string
        default: 'linux'
        description: 'Primary OS for build and pack. Options: linux, windows. Default: linux'
      requiresMacOS:
        required: false
        type: boolean
        default: false
        description: 'If true, also builds and tests on macOS (never releases from macOS)'
      runIntTestsOnPrimaryOsOnly:
        required: false
        type: boolean
        default: false
        description: 'If true, integration tests will only run on the primary build OS. Useful when integration tests only support a specific runtime (e.g., WPF on Windows).'
    secrets:
      NUGET_API_KEY:
        required: false
        description: 'NuGet.org API key for fallback package publishing.'
      NUGET_USER:
        required: false
        description: 'NuGet.org username (profile name) for Trusted Publishers (OIDC). Set this secret to enable NuGet package publishing. Use your profile name, NOT your email address.'
      SONAR_TOKEN:
        required: false
      SONAR_PROJECT_KEY:
        required: false
      SONAR_ORGANISATION_KEY:
        required: false
      VIRUSTOTAL_API_KEY:
        required: false
      CODECOV_TOKEN:
        required: false

jobs:
  build:
    uses: ./.github/workflows/_wfc_dotnet-ci-build.yml
    with:
      solutionName: ${{ inputs.solutionName }}
      useSlnx: ${{ inputs.useSlnx }}
      buildOs: ${{ inputs.buildOs }}
      requiresMacOS: ${{ inputs.requiresMacOS }}
      runIntTestsOnPrimaryOsOnly: ${{ inputs.runIntTestsOnPrimaryOsOnly }}
    secrets:
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
      SONAR_ORGANISATION_KEY: ${{ secrets.SONAR_ORGANISATION_KEY }}
      VIRUSTOTAL_API_KEY: ${{ secrets.VIRUSTOTAL_API_KEY }}
      CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  licenses:
    uses: ./.github/workflows/_wfc_dotnet-ci-licenses.yml
    with:
      solutionName: ${{ inputs.solutionName }}
      useSlnx: ${{ inputs.useSlnx }}

  snitch:
    uses: ./.github/workflows/_wfc_dotnet-ci-snitch.yml
    with:
      solutionName: ${{ inputs.solutionName }}
      useSlnx: ${{ inputs.useSlnx }}

  appinspector:
    uses: ./.github/workflows/_wfc_dotnet-ci-appinspector.yml
    with:
      solutionName: ${{ inputs.solutionName }}

  dependency-review:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v6
      - name: 'Dependency Review'
        uses: actions/dependency-review-action@v4
        with:
          comment-summary-in-pr: always

  validate-renovate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v6
      - uses: dpvreony/github-action-renovate-config-validator@63c5f53df823879a6cd46a10d27fbe1d4ede7839

  omd-generation:
    uses: ./.github/workflows/_wfc_dotnet-ci-omd-generation.yml
    with:
      solutionName: ${{ inputs.solutionName }}

  vulnerable-nuget-packages:
    uses: ./.github/workflows/_wfc_dotnet-ci-vulnerable-nuget-packages.yml
    with:
      solutionName: ${{ inputs.solutionName }}
      useSlnx: ${{ inputs.useSlnx }}

  deprecated-nuget-packages:
    uses: ./.github/workflows/_wfc_dotnet-ci-deprecated-nuget-packages.yml
    with:
      solutionName: ${{ inputs.solutionName }}
      useSlnx: ${{ inputs.useSlnx }}

  check-codeql-enabled:
    uses: ./.github/workflows/_wfc_dotnet-ci-check-codeql-enabled.yml

  codeql:
    needs: check-codeql-enabled
    if: needs.check-codeql-enabled.outputs.codeql_enabled == 'true'
    permissions:
      security-events: write
      packages: read
      actions: read
      contents: read
    uses: ./.github/workflows/_wfc_dotnet-ci-codeql.yml
    with:
      solutionName: ${{ inputs.solutionName }}

  check-nuget-user-populated:
    runs-on: ubuntu-latest
    outputs:
      has_nuget_user: ${{ steps.check.outputs.has_nuget_user }}
    env:
      NUGET_USER: ${{ secrets.NUGET_USER }}
    steps:
      - name: Check if NUGET_USER is set
        id: check
        run: |
          # Check if we have NUGET_USER configured
          if [ -n "$NUGET_USER" ]; then
            echo "::notice::NUGET_USER is configured. NuGet publishing enabled."
            echo "has_nuget_user=true" >> "$GITHUB_OUTPUT"
          else
            echo "::notice::NUGET_USER not configured."
            echo "has_nuget_user=false" >> "$GITHUB_OUTPUT"
          fi

  check-nuget-api-key-populated:
    runs-on: ubuntu-latest
    outputs:
      has_api_key: ${{ steps.check.outputs.has_api_key }}
    env:
      NUGET_API_KEY: ${{ secrets.nuget_api_key }}
    steps:
      - name: Check if NUGET_API_KEY is set
        id: check
        run: |
          if [ -n "$NUGET_API_KEY" ]; then
            echo "::notice::NUGET_API_KEY is configured. NuGet publishing enabled."
            echo "has_api_key=true" >> "$GITHUB_OUTPUT"
          else
            echo "::notice::NUGET_API_KEY not configured."
            echo "has_api_key=false" >> "$GITHUB_OUTPUT"
          fi
          
  check-nuget-trusted-publisher-valid:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    needs:
      check-nuget-user-populated
    if: needs.check-nuget-user-populated.outputs.has_nuget_user == 'true'
    steps:
      - name: Validate NuGet Trusted Publisher login
        uses: NuGet/login@v1
        id: nuget-login-test
        with:
          user: ${{ secrets.NUGET_USER }}
      
      - name: Confirm Trusted Publisher is valid
        run: |
          if [ -n "${{ steps.nuget-login-test.outputs.NUGET_API_KEY }}" ]; then
            echo "::notice::Successfully validated NuGet Trusted Publisher. Temporary API key obtained."
          else
            echo "::error::Failed to obtain temporary API key from NuGet Trusted Publisher."
            exit 1
          fi
     
  check-nuget-environment:
    permissions:
      actions: read
      contents: read
      deployments: read
    runs-on: ubuntu-latest
    needs:
      - check-nuget-user-populated
      - check-nuget-api-key-populated
      - check-nuget-trusted-publisher-valid
    if: |
      always() &&
      !cancelled() &&
      !failure() &&
      (needs.check-nuget-user-populated.outputs.has_nuget_user == 'true' || needs.check-nuget-api-key-populated.outputs.has_api_key == 'true')
    steps:
      - name: Check if 'nuget' environment exists and has protection rules
        uses: dpvreony/ensure-environment-protected@main
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          environment_name: 'nuget'

  check-release-required:
    permissions:
      contents: read
    runs-on: ubuntu-latest
    outputs:
      release_required: ${{ steps.check.outputs.release_required }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
      
      - name: Check if release is required
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Try to get the latest release
          latest_release=$(gh release list --limit 1 --json tagName --jq '.[0].tagName' 2>/dev/null || echo "")
          
          if [ -z "$latest_release" ]; then
            echo "No existing release found, release is required"
            echo "release_required=true" >> "$GITHUB_OUTPUT"
          else
            echo "Latest release: $latest_release"
            
            # Check if this build is older than the latest release
            # Get commit SHA for the latest release
            latest_sha=$(git rev-list -n 1 "$latest_release" 2>/dev/null || echo "")
            current_sha="${{ github.sha }}"
            
            if [ -n "$latest_sha" ]; then
              # Check if current commit is an ancestor of latest release
              # If current is an ancestor of latest, then latest is newer and we should not release
              if git merge-base --is-ancestor "$current_sha" "$latest_sha" 2>/dev/null; then
                echo "::warning::Current commit is older than the latest release ($latest_release). This build will not trigger a release."
                echo "release_required=false" >> "$GITHUB_OUTPUT"
                exit 0
              fi
            fi
            
            # Get diff between current commit and latest release tag
            # Check if there are changes in src/ excluding *.*Tests folders
            changed_files=$(git diff --name-only "$latest_release" HEAD -- src/ \
              | grep -v '.*\..*Tests/' \
              | grep -v '.*\..*Benchmarks/' \
              | grep -v '.*\..*Testing/' || true)
            
            if [ -n "$changed_files" ]; then
              echo "Changes detected in non-test files:"
              echo "$changed_files"
              echo "release_required=true" >> "$GITHUB_OUTPUT"
            else
              echo "No changes in non-test files, release not required"
              echo "release_required=false" >> "$GITHUB_OUTPUT"
            fi
          fi

  release:
    if: ${{ 'refs/heads/main' == github.ref && needs.check-release-required.outputs.release_required == 'true' }}
    permissions:
      contents: write
      pages: write
      id-token: write
      actions: write
    runs-on: ubuntu-latest
    needs: [build, check-nuget-environment, check-release-required]
    environment:
      name: nuget
    env:
      DOTNET_CLI_TELEMETRY_OPTOUT: 1
      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
      DOTNET_NOLOGO: true
      DOTNET_GENERATE_ASPNET_CERTIFICATE: false
    steps:
    - name: Cancel old pending releases
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        # Get the current version and SHA
        CURRENT_VERSION="${{ needs.build.outputs.nbgv }}"
        CURRENT_SHA="${{ github.sha }}"
        CURRENT_RUN_ID="${{ github.run_id }}"
        
        echo "Current release: $CURRENT_VERSION (SHA: $CURRENT_SHA, Run ID: $CURRENT_RUN_ID)"
        
        # Get all workflow runs that are waiting for approval on the nuget environment
        # Filter for runs on the default branch that are in 'waiting' status
        pending_runs=$(gh api \
          -H "Accept: application/vnd.github+json" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          "/repos/${{ github.repository }}/actions/runs?status=waiting&branch=${{ github.event.repository.default_branch }}" \
          --jq '.workflow_runs[] | select(.id != '$CURRENT_RUN_ID') | .id')
        
        if [ -z "$pending_runs" ]; then
          echo "No pending workflow runs found to cancel"
          exit 0
        fi
        
        echo "Found pending workflow runs to check: $pending_runs"
        
        # For each pending run, check if it has pending deployments for the nuget environment
        for run_id in $pending_runs; do
          echo "Checking run $run_id for pending deployments..."
          
          # Get pending deployments for this run
          pending_deployments=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/actions/runs/$run_id/pending_deployments" \
            --jq '.[] | select(.environment.name == "nuget") | .environment.id' 2>/dev/null || echo "")
          
          if [ -n "$pending_deployments" ]; then
            echo "Found pending deployment for nuget environment in run $run_id"
            
            # Reject the pending deployment
            for env_id in $pending_deployments; do
              echo "Rejecting deployment for environment $env_id in run $run_id"
              
              gh api \
                --method POST \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "/repos/${{ github.repository }}/actions/runs/$run_id/pending_deployments" \
                -f "environment_ids[]=$env_id" \
                -f "state=rejected" \
                -f "comment=Superseded by release $CURRENT_VERSION (SHA: $CURRENT_SHA) from run $CURRENT_RUN_ID" \
                && echo "Successfully rejected deployment in run $run_id" \
                || echo "Failed to reject deployment in run $run_id"
            done
          else
            echo "No pending nuget deployment found for run $run_id"
          fi
        done
        
        echo "Finished canceling old pending releases"
    
    - name: Download NuGet Packages
      uses: actions/download-artifact@v6
      with:
        name: nuget
    - name: Create Release
      uses: actions/create-release@v1
      env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # This token is provided by Actions, you do not need to create your own token
      with:
          tag_name: ${{ needs.build.outputs.nbgv }}
          release_name: ${{ needs.build.outputs.nbgv }}
          body: |
            ${{ needs.build.outputs.change_commit_log }}

    - name: NuGet login (OIDC â†’ temp API key)
      uses: NuGet/login@v1
      if: needs.check-nuget-user-populated.outputs.has_nuget_user == 'true'
      id: nuget-login
      with:
        user: ${{ secrets.NUGET_USER }}
    
    - name: NuGet Push (Trusted Publisher)
      if: needs.check-nuget-user-populated.outputs.has_nuget_user == 'true'
      env:
        NUGET_API_KEY: ${{ steps.nuget-login.outputs.NUGET_API_KEY }}
        SOURCE_URL: https://api.nuget.org/v3/index.json
      run: |
        echo "::notice::Using Trusted Publishers (OIDC) for NuGet push..."
        dotnet nuget push -s "$SOURCE_URL" -k "$NUGET_API_KEY" **/*.nupkg

    - name: NuGet Push (API_KEY)
      env:
        NUGET_AUTH_TOKEN: ${{ secrets.NUGET_API_KEY }}
        SOURCE_URL: https://api.nuget.org/v3/index.json
      if: needs.check-nuget-api-key-populated.outputs.has_api_key == 'true'
      run: |
        dotnet nuget push -s "$SOURCE_URL" -k "$NUGET_AUTH_TOKEN" **/*.nupkg
