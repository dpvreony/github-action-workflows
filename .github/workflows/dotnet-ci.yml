name: Common .NET setup and build workflow

on:
  workflow_call:
    inputs:
      solutionName:
        required: true
        type: string
        description: 'Name of the solution file WITHOUT the extension. On top of running the build. It is ued to calculate the format of the unit tests, benchmarks and integration tests.'
      buildOs:
        required: false
        type: string
        default: 'linux'
        description: 'Primary OS for build and pack. Options: linux, windows. Default: linux'
      requiresMacOS:
        required: false
        type: boolean
        default: false
        description: 'If true, also builds and tests on macOS (never releases from macOS)'
    secrets:
      NUGET_API_KEY:
        required: false
        description: 'API key used to release NUGET packages. Optional when using Trusted Publishers (OIDC).'
      SONAR_TOKEN:
        required: false
      SONAR_PROJECT_KEY:
        required: false
      SONAR_ORGANISATION_KEY:
        required: false
      VIRUSTOTAL_API_KEY:
        required: false
      CODECOV_TOKEN:
        required: false

jobs:
  build:
    uses: ./.github/workflows/_wfc_dotnet-ci-build.yml
    with:
      solutionName: ${{ inputs.solutionName }}
      buildOs: ${{ inputs.buildOs }}
      requiresMacOS: ${{ inputs.requiresMacOS }}
    secrets:
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
      SONAR_PROJECT_KEY: ${{ secrets.SONAR_PROJECT_KEY }}
      SONAR_ORGANISATION_KEY: ${{ secrets.SONAR_ORGANISATION_KEY }}
      VIRUSTOTAL_API_KEY: ${{ secrets.VIRUSTOTAL_API_KEY }}
      CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}

  licenses:
    uses: ./.github/workflows/_wfc_dotnet-ci-licenses.yml
    with:
      solutionName: ${{ inputs.solutionName }}

  snitch:
    uses: ./.github/workflows/_wfc_dotnet-ci-snitch.yml
    with:
      solutionName: ${{ inputs.solutionName }}

  appinspector:
    uses: ./.github/workflows/_wfc_dotnet-ci-appinspector.yml
    with:
      solutionName: ${{ inputs.solutionName }}

  dependency-review:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: 'Checkout Repository'
        uses: actions/checkout@v5
      - name: 'Dependency Review'
        uses: actions/dependency-review-action@v4
        with:
          comment-summary-in-pr: always

  validate-renovate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      - uses: dpvreony/github-action-renovate-config-validator@63c5f53df823879a6cd46a10d27fbe1d4ede7839

  omd-generation:
    uses: ./.github/workflows/_wfc_dotnet-ci-omd-generation.yml
    with:
      solutionName: ${{ inputs.solutionName }}

  vulnerable-nuget-packages:
    uses: ./.github/workflows/_wfc_dotnet-ci-vulnerable-nuget-packages.yml
    with:
      solutionName: ${{ inputs.solutionName }}

  deprecated-nuget-packages:
    uses: ./.github/workflows/_wfc_dotnet-ci-deprecated-nuget-packages.yml
    with:
      solutionName: ${{ inputs.solutionName }}

  check-codeql-enabled:
    uses: ./.github/workflows/_wfc_dotnet-ci-check-codeql-enabled.yml

  codeql:
    needs: check-codeql-enabled
    if: needs.check-codeql-enabled.outputs.codeql_enabled == 'true'
    permissions:
      security-events: write
      packages: read
      actions: read
      contents: read
    uses: ./.github/workflows/_wfc_dotnet-ci-codeql.yml
    with:
      solutionName: ${{ inputs.solutionName }}

  check-nuget-api-key:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    outputs:
      has_api_key: ${{ steps.check.outputs.has_api_key }}
      has_trusted_publisher: ${{ steps.check-oidc.outputs.has_trusted_publisher }}
    env:
      NUGET_API_KEY: ${{ secrets.nuget_api_key }}
    steps:
      - name: Check if NUGET_API_KEY is set
        id: check
        run: |
          if [ -n "$NUGET_API_KEY" ]; then
            echo "has_api_key=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_api_key=false" >> "$GITHUB_OUTPUT"
          fi
      
      - name: Check if OIDC token can be obtained (Trusted Publisher)
        id: check-oidc
        run: |
          # Check if we can get an OIDC token
          if [ -n "$ACTIONS_ID_TOKEN_REQUEST_URL" ] && [ -n "$ACTIONS_ID_TOKEN_REQUEST_TOKEN" ]; then
            echo "::notice::OIDC token request capability is available (Trusted Publisher support)"
            
            # Try to get a token to validate the setup
            TOKEN_RESPONSE=$(curl -s -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
              "$ACTIONS_ID_TOKEN_REQUEST_URL&audience=api://AzureADTokenExchange" || echo "")
            
            if [ -n "$TOKEN_RESPONSE" ] && echo "$TOKEN_RESPONSE" | grep -q "value"; then
              echo "::notice::Successfully obtained OIDC token for validation"
              echo "has_trusted_publisher=true" >> "$GITHUB_OUTPUT"
            else
              echo "::warning::Could not obtain OIDC token. Trusted Publisher may not be available."
              echo "has_trusted_publisher=false" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "::warning::OIDC token request variables not available. Trusted Publisher not supported in this environment."
            echo "has_trusted_publisher=false" >> "$GITHUB_OUTPUT"
          fi
     
  check-nuget-environment:
    permissions:
      actions: read
      contents: read
      deployments: read
    runs-on: ubuntu-latest
    needs:
      check-nuget-api-key
    if: needs.check-nuget-api-key.outputs.has_api_key == 'true' || needs.check-nuget-api-key.outputs.has_trusted_publisher == 'true'
    steps:
      - name: Check if 'nuget' environment exists and has protection rules
        uses: dpvreony/ensure-environment-protected@main
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          environment_name: 'nuget'

  check-release-required:
    permissions:
      contents: read
    runs-on: ubuntu-latest
    outputs:
      release_required: ${{ steps.check.outputs.release_required }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      
      - name: Check if release is required
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Try to get the latest release
          latest_release=$(gh release list --limit 1 --json tagName --jq '.[0].tagName' 2>/dev/null || echo "")
          
          if [ -z "$latest_release" ]; then
            echo "No existing release found, release is required"
            echo "release_required=true" >> "$GITHUB_OUTPUT"
          else
            echo "Latest release: $latest_release"
            
            # Check if this build is older than the latest release
            # Get commit SHA for the latest release
            latest_sha=$(git rev-list -n 1 "$latest_release" 2>/dev/null || echo "")
            current_sha="${{ github.sha }}"
            
            if [ -n "$latest_sha" ]; then
              # Check if current commit is an ancestor of latest release
              # If current is an ancestor of latest, then latest is newer and we should not release
              if git merge-base --is-ancestor "$current_sha" "$latest_sha" 2>/dev/null; then
                echo "::warning::Current commit is older than the latest release ($latest_release). This build will not trigger a release."
                echo "release_required=false" >> "$GITHUB_OUTPUT"
                exit 0
              fi
            fi
            
            # Get diff between current commit and latest release tag
            # Check if there are changes in src/ excluding *.*Tests folders
            changed_files=$(git diff --name-only "$latest_release" HEAD -- src/ | grep -v '.*\..*Tests/' || true)
            
            if [ -n "$changed_files" ]; then
              echo "Changes detected in non-test files:"
              echo "$changed_files"
              echo "release_required=true" >> "$GITHUB_OUTPUT"
            else
              echo "No changes in non-test files, release not required"
              echo "release_required=false" >> "$GITHUB_OUTPUT"
            fi
          fi

  release:
    if: ${{ format('refs/heads/{0}', github.event.repository.default_branch) == github.ref && needs.check-release-required.outputs.release_required == 'true' }}
    permissions:
      contents: write
      pages: write
      id-token: write
      actions: write
    runs-on: ubuntu-latest
    needs: [build, check-nuget-environment, check-release-required]
    environment:
      name: nuget
    env:
      DOTNET_CLI_TELEMETRY_OPTOUT: 1
      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
      DOTNET_NOLOGO: true
      DOTNET_GENERATE_ASPNET_CERTIFICATE: false
    steps:
    - name: Cancel old pending releases
      env:
        GH_TOKEN: ${{ github.token }}
      run: |
        # Get the current version and SHA
        CURRENT_VERSION="${{ needs.build.outputs.nbgv }}"
        CURRENT_SHA="${{ github.sha }}"
        CURRENT_RUN_ID="${{ github.run_id }}"
        
        echo "Current release: $CURRENT_VERSION (SHA: $CURRENT_SHA, Run ID: $CURRENT_RUN_ID)"
        
        # Get all workflow runs that are waiting for approval on the nuget environment
        # Filter for runs on the default branch that are in 'waiting' status
        pending_runs=$(gh api \
          -H "Accept: application/vnd.github+json" \
          -H "X-GitHub-Api-Version: 2022-11-28" \
          "/repos/${{ github.repository }}/actions/runs?status=waiting&branch=${{ github.event.repository.default_branch }}" \
          --jq '.workflow_runs[] | select(.id != '$CURRENT_RUN_ID') | .id')
        
        if [ -z "$pending_runs" ]; then
          echo "No pending workflow runs found to cancel"
          exit 0
        fi
        
        echo "Found pending workflow runs to check: $pending_runs"
        
        # For each pending run, check if it has pending deployments for the nuget environment
        for run_id in $pending_runs; do
          echo "Checking run $run_id for pending deployments..."
          
          # Get pending deployments for this run
          pending_deployments=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/repos/${{ github.repository }}/actions/runs/$run_id/pending_deployments" \
            --jq '.[] | select(.environment.name == "nuget") | .environment.id' 2>/dev/null || echo "")
          
          if [ -n "$pending_deployments" ]; then
            echo "Found pending deployment for nuget environment in run $run_id"
            
            # Reject the pending deployment
            for env_id in $pending_deployments; do
              echo "Rejecting deployment for environment $env_id in run $run_id"
              
              gh api \
                --method POST \
                -H "Accept: application/vnd.github+json" \
                -H "X-GitHub-Api-Version: 2022-11-28" \
                "/repos/${{ github.repository }}/actions/runs/$run_id/pending_deployments" \
                -f "environment_ids[]=$env_id" \
                -f "state=rejected" \
                -f "comment=Superseded by release $CURRENT_VERSION (SHA: $CURRENT_SHA) from run $CURRENT_RUN_ID" \
                && echo "Successfully rejected deployment in run $run_id" \
                || echo "Failed to reject deployment in run $run_id"
            done
          else
            echo "No pending nuget deployment found for run $run_id"
          fi
        done
        
        echo "Finished canceling old pending releases"
    
    - name: Download NuGet Packages
      uses: actions/download-artifact@v5
      with:
        name: nuget
    - name: Create Release
      uses: actions/create-release@v1
      env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # This token is provided by Actions, you do not need to create your own token
      with:
          tag_name: ${{ needs.build.outputs.nbgv }}
          release_name: ${{ needs.build.outputs.nbgv }}
          body: |
            ${{ needs.build.outputs.change_commit_log }}

    - name: NuGet Push
      env:
        NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}
        SOURCE_URL: https://api.nuget.org/v3/index.json
      run: |
        # Check if we should use Trusted Publishers (OIDC) or API Key
        USE_TRUSTED_PUBLISHER=false
        
        if [ -n "$ACTIONS_ID_TOKEN_REQUEST_URL" ] && [ -n "$ACTIONS_ID_TOKEN_REQUEST_TOKEN" ]; then
          echo "::notice::OIDC token request capability is available. Attempting to use Trusted Publishers..."
          
          # Request OIDC token with NuGet.org as the audience
          # NuGet.org expects the audience to be "api://AzureADTokenExchange"
          TOKEN_RESPONSE=$(curl -s -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "$ACTIONS_ID_TOKEN_REQUEST_URL&audience=api://AzureADTokenExchange")
          
          if [ -n "$TOKEN_RESPONSE" ]; then
            OIDC_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.value' 2>/dev/null || echo "")
            
            if [ -n "$OIDC_TOKEN" ] && [ "$OIDC_TOKEN" != "null" ]; then
              echo "::notice::Successfully obtained OIDC token. Using Trusted Publishers for NuGet push."
              USE_TRUSTED_PUBLISHER=true
              export NUGET_AUTH_TOKEN="$OIDC_TOKEN"
            else
              echo "::warning::Could not extract OIDC token from response. Falling back to API key if available."
            fi
          else
            echo "::warning::Could not obtain OIDC token response. Falling back to API key if available."
          fi
        else
          echo "::notice::OIDC token request not available. Using API key authentication."
        fi
        
        # Perform the push
        if [ "$USE_TRUSTED_PUBLISHER" = "true" ]; then
          echo "::notice::Pushing packages using Trusted Publishers (OIDC token)..."
          dotnet nuget push -s ${{ env.SOURCE_URL }} -k "$NUGET_AUTH_TOKEN" **/*.nupkg
        elif [ -n "$NUGET_API_KEY" ]; then
          echo "::notice::Pushing packages using API key..."
          dotnet nuget push -s ${{ env.SOURCE_URL }} -k "$NUGET_API_KEY" **/*.nupkg
        else
          echo "::error::Neither Trusted Publisher (OIDC) nor API key is available. Cannot push packages."
          exit 1
        fi
